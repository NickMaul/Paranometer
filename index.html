<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Paranometer — Energie-Scanner (Final)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#050608;
    --panel:#0c1113;
    --hud:#07c76b;
    --accent:#19e0b8;
    --muted: rgba(255,255,255,0.03);
    --danger:#ff4d4d;
    --glass: rgba(255,255,255,0.02);
  }
  *{box-sizing:border-box}
  body{margin:0; min-height:100vh; display:flex; align-items:center; justify-content:center; font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial; background:
        radial-gradient(800px 400px at 10% 10%, rgba(7,199,107,0.02), transparent 6%),
        linear-gradient(180deg,#030405 0%, #061012 100%);
       color:var(--hud); -webkit-font-smoothing:antialiased;}
  .container{width:min(980px,96vw); padding:20px;}
  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005)); border-radius:14px; border:1px solid rgba(7,199,107,0.06); padding:18px; box-shadow:0 14px 50px rgba(0,0,0,0.6)}
  .header{display:flex; align-items:center; gap:14px}
  .logo{width:58px;height:58px;border-radius:10px;background:linear-gradient(135deg, rgba(7,199,107,0.12), rgba(25,224,184,0.06));display:flex;align-items:center;justify-content:center;font-weight:700;color:#00110a;font-size:24px}
  h1{margin:0;font-size:20px;color:var(--accent)}
  p.lead{margin:6px 0 0 0; color:rgba(31,255,166,0.95); opacity:0.95; font-size:13px}
  .row{display:flex; gap:18px; margin-top:16px; flex-wrap:wrap}
  .left{flex:1; min-width:320px; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.02)); border-radius:12px; padding:16px; border:1px solid var(--muted)}
  .right{width:300px; min-width:240px; border-radius:12px; padding:14px; background:transparent; color:rgba(180,255,210,0.95)}

  /* Gauge */
  .gauge-wrap{position:relative; height:220px; display:flex; align-items:center; justify-content:center;}
  .gauge{width:420px; height:220px; position:relative;}
  .gauge-face{position:absolute; inset:0; border-radius:220px 220px 0 0; overflow:visible; background:linear-gradient(180deg, rgba(7,199,107,0.02), rgba(0,0,0,0)); box-shadow: inset 0 -8px 30px rgba(0,0,0,0.6);}
  /* outer ticks */
  #ticksContainer {position:absolute; inset:0; pointer-events:none; z-index:15;}
  .tick{position:absolute; left:50%; bottom:8px; transform-origin:50% 92%;}
  .tick-line{width:2px; height:12px; background:rgba(7,199,107,0.12); transform-origin:50% 100%;}
  .tick-label{position:absolute; bottom:28px; left:50%; transform:translateX(-50%); color:var(--hud); font-size:12px; letter-spacing:0.6px; text-shadow:0 4px 12px rgba(1,5,2,0.6)}

  /* needle */
  .needle-wrap{position:absolute; left:50%; bottom:8px; width:6px; height:150px; transform-origin:50% 92%; pointer-events:none; z-index:20}
  .needle{position:absolute; left:50%; bottom:0; width:6px; height:96px; transform-origin:50% 92%; border-radius:4px; background:linear-gradient(180deg, var(--hud), rgba(0,0,0,0.15)); transform:rotate(-90deg); box-shadow:0 10px 30px rgba(0,0,0,0.5), 0 0 18px rgba(7,199,107,0.06) inset}
  .needle::after{content:""; position:absolute; left:50%; top:-14px; transform:translateX(-50%); width:18px; height:18px; border-radius:50%; background:var(--accent); box-shadow:0 0 24px rgba(25,224,184,0.9)}
  .needle.vibe{animation:needleShake 0.16s infinite linear}
  @keyframes needleShake{ 0%{transform:rotate(var(--angle));}25%{transform:rotate(calc(var(--angle)+2deg));}50%{transform:rotate(calc(var(--angle)-1.4deg));}75%{transform:rotate(calc(var(--angle)+1deg));}100%{transform:rotate(var(--angle));}}

  .gauge-center{position:absolute; left:50%; bottom:-8px; transform:translateX(-50%); width:12px; height:12px; border-radius:50%; background:var(--accent); box-shadow:0 0 18px rgba(25,224,184,0.7)}

  /* Controls */
  .controls{display:flex; gap:10px; align-items:center; margin-top:10px}
  button.primary{background:linear-gradient(180deg,var(--hud), var(--accent)); color:#02221a; border:none; padding:10px 14px; border-radius:10px; font-weight:700; cursor:pointer; box-shadow:0 8px 30px rgba(6,182,139,0.06)}
  button.ghost{background:transparent; border:1px solid rgba(255,255,255,0.03); color:var(--hud); padding:8px 12px; border-radius:10px; cursor:pointer}
  .status{margin-left:auto; color:rgba(150,255,200,0.9); font-size:13px}

  /* meter bar */
  .bar-wrap{display:flex; align-items:center; gap:12px; margin-top:12px}
  .bar{height:12px; background:rgba(7,199,107,0.06); border-radius:999px; flex:1; overflow:hidden; border:1px solid rgba(255,255,255,0.02)}
  .bar > i{display:block; height:100%; width:0%; background:linear-gradient(90deg, rgba(7,199,107,0.9), rgba(25,224,184,0.85)); transition:width 0.12s linear; box-shadow:0 10px 30px rgba(7,199,107,0.06)}

  .right h3{margin:0;color:var(--accent)}
  .right p{margin:6px 0 12px 0; color:rgba(180,255,210,0.9)}

  .info-tile{background:var(--glass); padding:10px; border-radius:8px; border:1px solid rgba(255,255,255,0.02); margin-bottom:8px}
  .info-tile .val{font-size:22px; font-weight:800; color:var(--accent)}

  /* modal G3 style (glitch + wobble) */
  .modal-back{position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:linear-gradient(90deg, rgba(0,0,0,0.8), rgba(0,0,0,0.95)); z-index:60}
  .modal{width:min(720px,92vw); background:linear-gradient(180deg,#071114,#030305); border-radius:12px; padding:18px; border:1px solid rgba(7,199,107,0.04); color:var(--accent); overflow:hidden}
  .modal h2{color:var(--accent); margin:0; font-size:20px}
  .modal p{color:rgba(180,255,210,0.95); margin:8px 0 0 0}
  .modal .big{font-size:38px; font-weight:900; margin-top:10px}
  .glitch { display:inline-block; position:relative; }
  .glitch::before, .glitch::after { content: attr(data-text); position:absolute; left:0; top:0; opacity:0.8; }
  .glitch::before { transform: translate(-2px,-2px); color: rgba(255,0,0,0.7); mix-blend-mode:screen; clip-path: polygon(0 0,100% 0,100% 45%,0 45%); }
  .glitch::after { transform: translate(2px,2px); color: rgba(0,255,200,0.6); mix-blend-mode:screen; clip-path: polygon(0 55%,100% 55%,100% 100%,0 100%); }
  .wobble { animation: wobbleNow 0.6s ease-in-out; }
  @keyframes wobbleNow { 0%{transform:translateY(0) skewX(0);}20%{transform:translateY(-6px) skewX(-2deg);}40%{transform:translateY(4px) skewX(2deg);}60%{transform:translateY(-2px) skewX(-1deg);}100%{transform:translateY(0) skewX(0);} }

  /* responsive */
  @media (max-width:820px){
    .row{flex-direction:column}
    .right{width:100%}
    .gauge{width:100%; height:200px}
  }
</style>
</head>
<body>
  <div class="container">
    <div class="panel" role="main" aria-live="polite">
      <div class="header">
        <div class="logo">P</div>
        <div>
          <h1>Paranometer</h1>
          <p class="lead">Energie-Scanner — drücke „Energielevel testen“ und lasse das Gerät die Umgebung ertasten.</p>
        </div>
        <div style="margin-left:auto; font-size:12px; color:rgba(180,255,210,0.85)">Secure • Silent • Tactical</div>
      </div>

      <div class="row">
        <div class="left">
          <div class="gauge-wrap">
            <div class="gauge" id="gauge">
              <div class="gauge-face"></div>
              <div id="ticksContainer"></div>
              <div class="needle-wrap">
                <div class="needle" id="needle" style="--angle:-90deg;"></div>
              </div>
              <div class="gauge-center"></div>
            </div>
          </div>

          <div class="controls">
            <button class="primary" id="startBtn">Energielevel testen</button>
            <button class="ghost" id="stopBtn" style="display:none">Stopp</button>
            <button class="ghost" id="resultBtn" style="display:none">Ergebnis anzeigen</button>
            <div class="status" id="status">Bereit</div>
          </div>

          <div class="bar-wrap" aria-hidden="false">
            <div style="min-width:110px; color:rgba(180,255,210,0.95); font-weight:700">Paranormales Level</div>
            <div class="bar"><i id="barFill"></i></div>
            <div style="width:56px; text-align:right; color:var(--accent); font-weight:800" id="percentText">0%</div>
          </div>
        </div>

        <div class="right">
          <h3>Monitore</h3>
          <p>Der Scanner ist auf Empfang. Interpretiere das Ergebnis mit Bedacht.</p>

          <div class="info-tile"><div style="font-size:12px">Momentanes Level</div><div class="val" id="currentVal">—%</div></div>
          <div class="info-tile"><div style="font-size:12px">Letzte Messung (für Ergebnis)</div><div class="val" id="lastVal">—%</div></div>

          <div style="margin-top:8px;">
            <div style="display:flex; gap:8px;">
              <button class="ghost" id="vibToggle">Vibration: AN</button>
              <button class="ghost" id="toneToggle">Ton: AN</button>
            </div>
          </div>

          <div style="margin-top:12px; color:rgba(160,255,200,0.9); font-size:13px">
            Stufen:
            <ul style="margin:8px 0 0 18px; padding:0; color:rgba(160,255,200,0.9)">
              <li>0–25%: Ruhig</li>
              <li>26–50%: Verstärkt</li>
              <li>51–75%: Aktiv</li>
              <li>76–100%: Kritisch</li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal Ergebnis (G3 visuals + strong SFX) -->
  <div class="modal-back" id="modalBack" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <h2 id="modalTitle"><span class="glitch" data-text="Analyse — Paranormales Profil">Analyse — Paranormales Profil</span></h2>
      <p id="modalText">Vorbereitung...</p>
      <div class="big" id="modalPercent">—%</div>
      <div style="display:flex; gap:10px; justify-content:flex-end; margin-top:12px">
        <button class="ghost" id="modalClose">Zurück</button>
        <button class="primary" id="modalRestart">Neu testen</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // CONFIG
  const MIN_FREQ = 50;
  const MAX_FREQ = 4000;
  const SMOOTH_TIME = 0.05;
  const VIBRATION_THRESHOLD_PERCENT = 85;
  const VIBRATION_COOLDOWN_MS = 900;
  const ULTRA_RARE_CHANCE = 0.01; // 1%

  // DOM
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const resultBtn = document.getElementById('resultBtn');
  const statusEl = document.getElementById('status');
  const needle = document.getElementById('needle');
  const barFill = document.getElementById('barFill');
  const percentText = document.getElementById('percentText');
  const currentVal = document.getElementById('currentVal');
  const lastVal = document.getElementById('lastVal');
  const vibToggle = document.getElementById('vibToggle');
  const toneToggle = document.getElementById('toneToggle');
  const modalBack = document.getElementById('modalBack');
  const modalText = document.getElementById('modalText');
  const modalPercent = document.getElementById('modalPercent');
  const modalClose = document.getElementById('modalClose');
  const modalRestart = document.getElementById('modalRestart');
  const ticksContainer = document.getElementById('ticksContainer');
  const modalTitle = document.getElementById('modalTitle');

  // Audio
  let audioCtx = null;
  let osc = null;
  let masterGain = null;
  let filter = null;
  let running = false;

  // measurement
  let currentPercent = 0;
  let lastMeasuredPercent = 0;
  let lastFreq = 0;
  let recording = false;

  // vibration + toggles
  let vibEnabled = true;
  let toneEnabled = true;
  let lastVibAt = 0;

  // Helpers
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const percentToAngle = p => (-90 + (p/100)*180);

  // Linear mapping: t in [0,1] -> frequency
  function tToFreqLinear(t) {
    const tt = clamp(t,0,1);
    return MIN_FREQ + tt * (MAX_FREQ - MIN_FREQ);
  }
  function freqToPercentLinear(freq) {
    const p = (clamp(freq,MIN_FREQ,MAX_FREQ) - MIN_FREQ) / (MAX_FREQ - MIN_FREQ);
    return Math.round(p * 100);
  }

  function setFrequencySmooth(value) {
    if (!audioCtx || !osc) return;
    const now = audioCtx.currentTime;
    try {
      osc.frequency.cancelScheduledValues(now);
      osc.frequency.setValueAtTime(osc.frequency.value || value, now);
      osc.frequency.linearRampToValueAtTime(value, now + SMOOTH_TIME);
    } catch(e) {
      try { osc.frequency.value = value; } catch(e){}
    }
  }

  function startAudio() {
    if (running) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    osc = audioCtx.createOscillator();
    masterGain = audioCtx.createGain();
    filter = audioCtx.createBiquadFilter();

    osc.type = 'sine';
    osc.frequency.value = MIN_FREQ;
    filter.type = 'lowpass';
    filter.frequency.value = 2000;
    filter.Q.value = 0.7;
    masterGain.gain.value = 0.12;

    osc.connect(filter);
    filter.connect(masterGain);
    masterGain.connect(audioCtx.destination);

    try { osc.start(); } catch(e){}

    running = true;
    recording = true;
    statusEl.textContent = 'EMPFANG: Aktiv';
    startBtn.style.display = 'none';
    stopBtn.style.display = 'inline-block';
    resultBtn.style.display = 'inline-block';
  }

  function stopAudioClean() {
    if (!running) return;
    try { osc.stop(); } catch(e){}
    try { audioCtx.close(); } catch(e){}
    audioCtx=null; osc=null; masterGain=null; filter=null;
    running = false;
    recording = false;
    statusEl.textContent = 'Gestoppt';
    startBtn.style.display = 'inline-block';
    stopBtn.style.display = 'none';
    resultBtn.style.display = 'none';
  }

  // Deviceorientation handler (hidden trigger -> maps to energy)
  function handleOrientation(ev) {
    if (!ev) return;
    const beta = (typeof ev.beta === 'number') ? ev.beta : 0;
    const gamma = (typeof ev.gamma === 'number') ? ev.gamma : 0;
    // combine magnitude
    const a = Math.abs(beta), b = Math.abs(gamma);
    let tilt = Math.sqrt(a*a + b*b) / Math.SQRT2;
    tilt = clamp(tilt, 0, 90);
    const t = tilt / 90;
    const freq = tToFreqLinear(t);
    const percent = Math.round(t * 100);

    // update current
    currentPercent = percent;
    lastFreq = freq;

    // UI update (no angles shown)
    currentVal.textContent = percent + '%';
    percentText.textContent = percent + '%';
    barFill.style.width = percent + '%';

    // needle rotation & color
    const angle = percentToAngle(percent);
    needle.style.setProperty('--angle', angle + 'deg');
    needle.style.transform = `rotate(${angle}deg)`;
    const color = pickColorForPercent(percent);
    needle.style.background = `linear-gradient(180deg, ${color} 0%, rgba(0,0,0,0.15) 100%)`;
    needle.style.boxShadow = `0 10px 30px rgba(0,0,0,0.5), 0 0 18px ${hexToRgba(color,0.06)} inset`;
    const orb = document.querySelector('.gauge-center');
    orb.style.background = (percent >= 70 ? 'var(--danger)' : 'var(--accent)');

    if (percent >= 90) needle.classList.add('vibe'); else needle.classList.remove('vibe');

    // vibration device
    const now = Date.now();
    if (vibEnabled && percent >= VIBRATION_THRESHOLD_PERCENT && (now - lastVibAt) > VIBRATION_COOLDOWN_MS) {
      lastVibAt = now;
      try { if (navigator.vibrate) navigator.vibrate(140); } catch(e){}
    }

    // audio update
    if (running && toneEnabled && audioCtx && osc) {
      setFrequencySmooth(freq);
      const filterCut = clamp(Math.max(200, freq * 2), 200, 20000);
      try {
        filter.frequency.cancelScheduledValues(audioCtx.currentTime);
        filter.frequency.setValueAtTime(filter.frequency.value || filterCut, audioCtx.currentTime);
        filter.frequency.linearRampToValueAtTime(filterCut, audioCtx.currentTime + SMOOTH_TIME * 1.2);
      } catch(e){}
    }
  }

  // color logic
  function pickColorForPercent(p) {
    if (p <= 25) return '#05ff92';
    if (p <= 50) return '#fff85a';
    if (p <= 75) return '#ffb24f';
    return '#ff4d4d';
  }
  function hexToRgba(hex, a){
    hex = hex.replace('#','');
    const r = parseInt(hex.substring(0,2),16);
    const g = parseInt(hex.substring(2,4),16);
    const b = parseInt(hex.substring(4,6),16);
    return `rgba(${r},${g},${b},${a})`;
  }

  // Permission flow for iOS
  async function requestSensorPermissionIfNeeded() {
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
      try {
        const result = await DeviceOrientationEvent.requestPermission();
        return result === 'granted';
      } catch (err) {
        console.warn('Permission request failed:', err);
        return false;
      }
    } else {
      return true;
    }
  }

  // Start handler
  startBtn.addEventListener('click', async () => {
    statusEl.textContent = 'Ermittle Zugriff...';
    const ok = await requestSensorPermissionIfNeeded();
    if (!ok) {
      statusEl.textContent = 'Zugriff verweigert – Einstellungen prüfen.';
      return;
    }
    // unlock audio
    try {
      if (!audioCtx) startAudio();
      else await audioCtx.resume();
    } catch (e) {
      statusEl.textContent = 'Audio-Start fehlgeschlagen.';
      return;
    }
    // register sensors
    window.addEventListener('deviceorientation', handleOrientation, true);
    statusEl.textContent = 'EMPFANG: Aktiv';
    lastVal.textContent = '—%';
  });

  // stop
  stopBtn.addEventListener('click', () => {
    window.removeEventListener('deviceorientation', handleOrientation, true);
    if (audioCtx && audioCtx.state === 'running') {
      try { audioCtx.suspend(); } catch(e){}
    }
    running = false;
    statusEl.textContent = 'Gestoppt';
    stopBtn.style.display = 'none';
    startBtn.style.display = 'inline-block';
  });

  // result: uses last measured currentPercent only (no peak)
  resultBtn.addEventListener('click', async () => {
    lastMeasuredPercent = currentPercent;
    lastVal.textContent = lastMeasuredPercent + '%';
    // show modal (G3 visuals) and play SFX depending on level
    showResultModal(lastMeasuredPercent);
    // pause audio for clarity
    try { if (audioCtx && audioCtx.state === 'running') await audioCtx.suspend(); } catch(e){}
    statusEl.textContent = 'Ergebnis angezeigt';
  });

  // toggles
  vibToggle.addEventListener('click', () => {
    vibEnabled = !vibEnabled;
    vibToggle.textContent = 'Vibration: ' + (vibEnabled ? 'AN' : 'AUS');
  });
  toneToggle.addEventListener('click', () => {
    toneEnabled = !toneEnabled;
    toneToggle.textContent = 'Ton: ' + (toneEnabled ? 'AN' : 'AUS');
    if (!toneEnabled && masterGain && audioCtx) {
      try { masterGain.gain.setValueAtTime(0.0001, audioCtx.currentTime); } catch(e){}
    } else if (toneEnabled && masterGain && audioCtx) {
      try { masterGain.gain.setValueAtTime(0.12, audioCtx.currentTime); } catch(e){}
    }
  });

  // Modal logic with many messages & Easter eggs
  const messages = {
    low: [
      "Keine nennenswerte Präsenz festgestellt.",
      "Störquellen: vermutlich Lampen und Staub.",
      "Hier spukt höchstens dein Router.",
      "Sanfte Ruhe. Keine Anomalien detektiert.",
      "Die Luft ist kalt, aber unauffällig.",
      "Wahrscheinlich nur EMV vom Kühlschrank.",
      "Nur schwaches Fluktuationsrauschen.",
      "Keine Entität in Reichweite.",
      "Atmosphäre neutral — weitermachen wenn du willst.",
      "Messung normal — keine Aktion erforderlich."
    ],
    mid: [
      "Eine Präsenz ist in der Nähe — vorsichtig.",
      "Etwas beobachtet dich, bleibt aber distanziert.",
      "Leichte energetische Störung registriert.",
      "Unklare Signaturen — erhöhte Aufmerksamkeit empfohlen.",
      "Es könnte eine schwache Präsenz sein.",
      "Spuren von Aktivität — dokumentiere Zeit & Ort.",
      "Flimmernde Signale — möglicherweise temporär.",
      "Ein Flüstern im Rauschen — hör genau hin.",
      "Unregelmäßige Muster erkannt.",
      "Der Scanner nimmt Interaktion wahr."
    ],
    high: [
      "Signifikante Präsenzdetektion. Bleibe ruhig.",
      "Es beobachtet dich. Distanz wahren.",
      "Starke energetische Signale — erhöhte Vorsicht.",
      "Die Entität reagiert auf Anwesenheit.",
      "Anomalie aktiv — dokumentiere alles.",
      "Hohe Fluktuation — mögliche Manifestation.",
      "Räume verändern leicht ihre Sensorik.",
      "Nicht provozieren — reduziere Störquellen.",
      "Starke Signatur — handele überlegt.",
      "Die Umgebung reagiert auf Messung."
    ],
    critical: [
      "Starke energetische Anomalie! Verlasse den Bereich.",
      "Sehr hohe Aktivität — Verhalten ändern empfohlen.",
      "Warnung: Intensive Signale. Schütze dich.",
      "Akute Präsenz — bleibe still und dokumentiere.",
      "Unruhe hoch — potenzielle Manifestation.",
      "Extremes Rauschen – Abstand nehmen empfohlen.",
      "Energie konzentriert — mögliche Gefährdung.",
      "Starke Interaktion – sichere Umgebung jetzt.",
      "Gefahrensignal — suche sichere Zone.",
      "Höhere Gewalt registriert — vorsichtig handeln."
    ],
    ultra: [
      "VERBINDUNG HERGESTELLT. DU HÄTTEST NICHT ÖFFNEN DÜRFEN.",
      "CODE PHANTOM: Authentifizierung fehlgeschlagen.",
      "Koordinaten empfangen: 48.85 N, 2.35 E. Unbekannt.",
      "Ektoplasma Level 9000! ...IT'S OVER NINE THOUSAAAAND!",
      "Spiritus.exe hat aufgehört zu funktionieren.",
      "Error 666: Ritual konnte nicht geladen werden.",
      "Die Verbindung flüstert: „Wir sehen dich.“",
      "Die Linie zwischen den Welten ist dünn.",
      "Die Entität sagt: „Danke, dass du angerufen hast.“",
      "DAS PROTOKOLL IST AKTIVIERT. FLIEHE NICHT."
    ]
  };

  // pick message depending on percent and 1% Ultra chance
  function pickMessage(percent) {
    // Ultra rare chance override
    if (Math.random() < ULTRA_RARE_CHANCE) {
      const u = messages.ultra;
      return u[Math.floor(Math.random()*u.length)];
    }
    if (percent <= 20) return randomFrom(messages.low);
    if (percent <= 50) return randomFrom(messages.mid);
    if (percent <= 80) return randomFrom(messages.high);
    return randomFrom(messages.critical);
  }
  function randomFrom(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  // SFX generation for results: stronger SFX for mid/high/critical & ultra
  function playResultSFX(percent, ultra=false) {
    // Use short webaudio sound: an impact + low rumble; stronger at higher percent
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const now = ctx.currentTime;

      // base impact
      const impact = ctx.createOscillator();
      const impactGain = ctx.createGain();
      impact.type = 'sawtooth';
      const baseFreq = 80 + Math.round(percent/100 * 400); // 80..480
      impact.frequency.setValueAtTime(baseFreq, now);
      impactGain.gain.setValueAtTime(0.0001, now);
      impactGain.gain.linearRampToValueAtTime(0.18 + percent/100 * 0.25, now + 0.006);
      impactGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.6);

      // low rumble
      const rumble = ctx.createOscillator();
      const rumbleGain = ctx.createGain();
      rumble.type = 'sine';
      rumble.frequency.setValueAtTime(30 + percent/100 * 40, now);
      rumbleGain.gain.setValueAtTime(0.0001, now);
      rumbleGain.gain.linearRampToValueAtTime(0.05 + percent/100 * 0.08, now + 0.02);
      rumbleGain.gain.exponentialRampToValueAtTime(0.0001, now + 1.2);

      // optional high scary tick for ultra
      let ultraOsc = null, ultraGain = null;
      if (ultra) {
        ultraOsc = ctx.createOscillator();
        ultraGain = ctx.createGain();
        ultraOsc.type = 'triangle';
        ultraOsc.frequency.setValueAtTime(1200, now);
        ultraGain.gain.setValueAtTime(0.0001, now);
        ultraGain.gain.linearRampToValueAtTime(0.22, now + 0.01);
        ultraGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.9);
      }

      impact.connect(impactGain);
      rumble.connect(rumbleGain);
      impactGain.connect(ctx.destination);
      rumbleGain.connect(ctx.destination);
      if (ultra) { ultraOsc.connect(ultraGain); ultraGain.connect(ctx.destination); }

      impact.start(now);
      rumble.start(now);
      if (ultra) ultraOsc.start(now);

      impact.stop(now + 0.7);
      rumble.stop(now + 1.2);
      if (ultra) ultraOsc.stop(now + 0.95);

      // close context later
      setTimeout(()=>{ try{ ctx.close(); } catch(e){} }, 1500);
    } catch(e){
      console.warn('SFX failed', e);
    }
  }

  // show result modal with G3 visuals + strong SFX (like G2 strength)
  function showResultModal(percent) {
    const msg = pickMessage(percent);
    // apply glitch + wobble visual
    modalBack.style.display = 'flex';
    modalBack.setAttribute('aria-hidden','false');
    modalText.textContent = msg;
    modalPercent.textContent = percent + '%';
    // add visual wobble/glitch
    const modal = modalBack.querySelector('.modal');
    modal.classList.remove('wobble');
    void modal.offsetWidth;
    modal.classList.add('wobble');
    // choose sfx: ultra gives special sfx
    const isUltra = messages.ultra.includes(msg);
    const sfxPercent = clamp(percent,0,100);
    // stronger SFX matching request (G2 strength) — and ultra gives extra
    playResultSFX(sfxPercent, isUltra);
    // micro vibration for very high
    if (vibEnabled && percent >= VIBRATION_THRESHOLD_PERCENT) {
      try { if (navigator.vibrate) navigator.vibrate([120,40,120]); } catch(e){}
    }
    // overlay title glitch text update
    const glitchEl = modalTitle.querySelector('.glitch');
    if (glitchEl) glitchEl.dataset.text = "Analyse — Paranormales Profil";
  }

  modalClose.addEventListener('click', () => {
    modalBack.style.display = 'none';
    modalBack.setAttribute('aria-hidden','true');
    statusEl.textContent = 'Lauf pausiert';
  });
  modalRestart.addEventListener('click', () => {
    modalBack.style.display = 'none';
    modalBack.setAttribute('aria-hidden','true');
    // reset last measurement and resume
    lastVal.textContent = '—%';
    barFill.style.width = '0%';
    percentText.textContent = '0%';
    currentVal.textContent = '—%';
    currentPercent = 0;
    try {
      if (!audioCtx) startAudio();
      else audioCtx.resume();
      window.addEventListener('deviceorientation', handleOrientation, true);
      statusEl.textContent = 'EMPFANG: Aktiv';
    } catch(e){
      statusEl.textContent = 'Fehler beim Neustart';
    }
  });

  // ticks outer edge (0,25,50,75,100)
  function createTicks() {
    ticksContainer.innerHTML = '';
    const labels = [0,25,50,75,100];
    labels.forEach(p => {
      const el = document.createElement('div');
      el.className = 'tick';
      const angle = percentToAngle(p);
      el.style.transform = `rotate(${angle}deg) translateY(-6px)`;
      el.style.left = '50%'; el.style.bottom = '8px';
      const line = document.createElement('div');
      line.className = 'tick-line';
      line.style.height = '14px';
      el.appendChild(line);
      const label = document.createElement('div');
      label.className = 'tick-label';
      label.textContent = p + '%';
      label.style.transform = `rotate(${-angle}deg) translateY(-10px)`;
      el.appendChild(label);
      ticksContainer.appendChild(el);
    });
  }
  setTimeout(createTicks, 120);

  // best-effort resume on touchend
  document.body.addEventListener('touchend', async () => {
    if (audioCtx && audioCtx.state === 'suspended') {
      try { await audioCtx.resume(); } catch(e){}
    }
  }, {passive:true});

  // fallback message
  setTimeout(() => {
    if (typeof DeviceOrientationEvent === 'undefined' && typeof window.DeviceMotionEvent === 'undefined') {
      statusEl.textContent = 'Dieses Gerät unterstützt keine Bewegungssensoren.';
    }
  }, 900);

  // cleanup
  window.addEventListener('pagehide', () => {
    try { window.removeEventListener('deviceorientation', handleOrientation, true); } catch(e){}
    try { if (audioCtx) audioCtx.close(); } catch(e){}
  });

  // init
  vibToggle.textContent = 'Vibration: AN';
  toneToggle.textContent = 'Ton: AN';

})();
</script>
</body>
</html>
